import React, { useRef, useEffect, useState } from 'react';
import { View, Text, ScrollView, TouchableOpacity, StyleSheet, ActivityIndicator, Modal, Alert, Switch } from 'react-native';
import { Subtitle } from '../utils/subtitles';
import { decodeHtmlEntities } from '../utils/textUtils';
import { translateText } from '../utils/translation';
import { fetchWordMeaning } from '../utils/dictionary';
import { saveVocabularyItem } from '../utils/vocabulary';
import { WordMeaning } from '../types/dictionary';
import { VocabularyItem } from '../types/vocabulary';
import { useSettings } from '../contexts/SettingsContext';
import { getTranslationFromCache, saveTranslationToCache } from '../utils/translationCache';

interface Props {
  currentSubtitle: Subtitle | null;
  subtitles: Subtitle[];
  currentTime: number;
  onTimeChange: (time: number) => void;
  videoInfo: {
    title: string;
    thumbnailUrl: string;
    videoId: string;
  };
  onWordPress?: () => void;
}

export const SubtitleDisplay = ({ currentSubtitle, subtitles, currentTime, onTimeChange, videoInfo, onWordPress }: Props) => {
  const scrollViewRef = useRef<ScrollView>(null);
  const BASE_ITEM_HEIGHT = 100;
  const SCROLL_OFFSET = 2;
  const [translations, setTranslations] = useState<Record<number, string>>({});
  const [loadingTranslations, setLoadingTranslations] = useState<Record<number, boolean>>({});
  const [translationQueue, setTranslationQueue] = useState<number[]>([]);
  const [selectedWord, setSelectedWord] = useState<string | null>(null);
  const [showWordModal, setShowWordModal] = useState(false);
  const [wordMeaning, setWordMeaning] = useState<WordMeaning | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const { settings } = useSettings();

  const handleTranslation = async (subtitle: Subtitle) => {
    console.log('handleTranslation', subtitle.id);
    if (!subtitle.translation && 
        !translations[subtitle.id] && 
        !loadingTranslations[subtitle.id] && 
        !translationQueue.includes(subtitle.id)) {
      
      const cachedTranslation = await getTranslationFromCache(subtitle.text);
      if (cachedTranslation) {
        setTranslations(prev => ({ ...prev, [subtitle.id]: cachedTranslation }));
        return;
      }
      
      setTranslationQueue(prev => [...prev, subtitle.id]);
    }
  };

  useEffect(() => {
    const processQueue = async () => {
      if (translationQueue.length > 0) {
        const subtitleId = translationQueue[0];
        const subtitle = subtitles.find(s => s.id === subtitleId);
        
        if (subtitle && !translations[subtitleId]) {
          setLoadingTranslations(prev => ({ ...prev, [subtitleId]: true }));
          
          try {
            const translatedText = await translateText(subtitle.text);
            if (translatedText) {
              setTranslations(prev => ({ ...prev, [subtitleId]: translatedText }));
              await saveTranslationToCache(subtitle.text, translatedText);
            }
          } finally {
            setLoadingTranslations(prev => ({ ...prev, [subtitleId]: false }));
            setTranslationQueue(prev => prev.slice(1));
          }
        }
      }
    };

    processQueue();
  }, [translationQueue, subtitles]);

  useEffect(() => {
    const visibleSubtitles = subtitles.filter(subtitle => 
      Math.abs(currentTime - subtitle.startTime) < 10 &&
      !subtitle.translation &&
      !translations[subtitle.id] &&
      !translationQueue.includes(subtitle.id)
    );

    visibleSubtitles.forEach(subtitle => {
      handleTranslation(subtitle);
    });
  }, [currentTime, subtitles]);

  const calculateSubtitleHeight = (text: string, isAutoGenerated: boolean = false): number => {
    const wordCount = text.split(' ').length;
    const baseHeight = BASE_ITEM_HEIGHT;
    
    if (isAutoGenerated) {
      if (wordCount > 8) {
        const additionalLines = Math.ceil((wordCount - 8) / 4);
        return baseHeight + (additionalLines * 24);
      }
      return baseHeight + 16;
    }
    else if (wordCount > 20) {
      const additionalLines = Math.ceil((wordCount - 20) / 10);
      return baseHeight + (additionalLines * 20);
    }
    return baseHeight;
  };

  const calculateScrollPosition = (currentIndex: number): number => {
    let position = 0;
    if (subtitles[currentIndex]?.isAutoGenerated) {
      for (let i = 0; i < currentIndex; i++) {
        position += calculateSubtitleHeight(subtitles[i].text, subtitles[i].isAutoGenerated) + 8;
      }
      return position;
    }
    for (let i = 0; i < currentIndex; i++) {
      position += calculateSubtitleHeight(subtitles[i].text, subtitles[i].isAutoGenerated) + 8;
    }
    return Math.max(0, position - 160);
  };

  useEffect(() => {
    if (currentSubtitle && scrollViewRef.current) {
      const currentIndex = subtitles.findIndex(s => s.id === currentSubtitle.id);
      if (currentIndex !== -1) {
        const scrollPosition = calculateScrollPosition(currentIndex);
        
        scrollViewRef.current.scrollTo({
          y: scrollPosition,
          animated: true
        });
      }
    }
  }, [currentSubtitle?.id, subtitles]);

  const getSubtitleItemStyle = (subtitle: Subtitle, isCurrentlyPlaying: boolean) => {
    const height = calculateSubtitleHeight(subtitle.text, subtitle.isAutoGenerated);
    return [
      styles.subtitleItem,
      { height },
      isCurrentlyPlaying && styles.currentSubtitle,
      subtitle.isAutoGenerated && styles.autoGeneratedSubtitle
    ];
  };

  const handleSubtitlePress = (startTime: number) => {
    onTimeChange(startTime);

    console.log('handleSubtitlePress', startTime);
  };

  const handleWordPress = async (word: string) => {
    console.log('handleWordPress - word:', word);
    
    if (onWordPress) {
      console.log('handleWordPress - pausing video');
      onWordPress();
    }
    
    setSelectedWord(word);
    setShowWordModal(true);
    setIsLoading(true);
    
    try {
      console.log('handleWordPress - fetching word data...');
      const [meaning, translation] = await Promise.all([
        fetchWordMeaning(word),
        translateText(word)
      ]);

      if (meaning) {
        console.log('handleWordPress - word data fetched successfully');
        const meaningData: WordMeaning = {
          definition: meaning.meanings[0]?.definitions[0]?.definition || '',
          japaneseTranslation: translation,
          partOfSpeech: meaning.meanings[0]?.partOfSpeech,
          example: meaning.meanings[0]?.definitions[0]?.example,
        };
        setWordMeaning(meaningData);
      }
    } catch (error) {
      console.error('handleWordPress - Error fetching word data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const updateScrollPosition = () => {
    console.log('updateScrollPosition - starting...');
    if (currentSubtitle && scrollViewRef.current) {
      const currentIndex = subtitles.findIndex(s => s.id === currentSubtitle.id);
      console.log('updateScrollPosition - currentIndex:', currentIndex);
      if (currentIndex !== -1) {
        const scrollPosition = calculateScrollPosition(currentIndex);
        console.log('updateScrollPosition - scrolling to position:', scrollPosition);
        scrollViewRef.current.scrollTo({
          y: scrollPosition,
          animated: true
        });
      }
    }
  };

  const handleSaveWord = async () => {
    console.log('handleSaveWord - starting...');
    console.log('handleSaveWord - selectedWord:', selectedWord);
    console.log('handleSaveWord - currentSubtitle:', currentSubtitle);
    
    if (selectedWord && wordMeaning && currentSubtitle) {
      try {
        const vocabularyItem: VocabularyItem = {
          word: selectedWord,
          japaneseTranslation: wordMeaning.japaneseTranslation || '',
          videoInfo: {
            title: videoInfo.title,
            thumbnailUrl: videoInfo.thumbnailUrl,
            subtitle: decodeHtmlEntities(currentSubtitle.text),
            translatedSubtitle: currentSubtitle.translation || translations[currentSubtitle.id] || '',
            videoId: videoInfo.videoId,
            startTime: currentSubtitle.startTime
          },
          timestamp: Date.now(),
          reviewInfo: {
            lastReviewDate: 0,
            nextReviewDate: Date.now(),
            reviewCount: 0,
            correctCount: 0,
            level: 0,
          },
        };
        
        console.log('handleSaveWord - saving vocabulary item:', vocabularyItem);
        const success = await saveVocabularyItem(vocabularyItem);
        console.log('handleSaveWord - save result:', success);
        
        if (success) {
          setShowWordModal(false);
          Alert.alert(
            '保存完了',
            '単語を保存しました',
            [
              {
                text: 'OK',
                onPress: () => {
                  console.log('handleSaveWord - OK pressed, resuming video');
                  if (onWordPress) {
                    onWordPress();
                  }
                  updateScrollPosition();
                }
              }
            ]
          );
        }
      } catch (error) {
        console.error('handleSaveWord - Error:', error);
        Alert.alert('エラー', '単語の保存に失敗しました');
      }
    } else {
      console.log('handleSaveWord - Missing required data:', {
        hasSelectedWord: !!selectedWord,
        hasWordMeaning: !!wordMeaning,
        hasCurrentSubtitle: !!currentSubtitle
      });
    }
  };

  const handleModalClose = () => {
    console.log('handleModalClose - closing modal');
    setShowWordModal(false);
    const currentIndex = subtitles.findIndex(s => s.id === currentSubtitle?.id);
    
    if (onWordPress) {
      console.log('handleModalClose - resuming video');
      onWordPress();
    }
    
    if (scrollViewRef.current && currentIndex !== -1) {
      console.log('handleModalClose - updating scroll position');
      const scrollPosition = calculateScrollPosition(currentIndex);
      setTimeout(() => {
        scrollViewRef.current?.scrollTo({
          y: scrollPosition,
          animated: true
        });
      }, 100);
    }
  };

  const cleanWord = (word: string): string => {
    return word.replace(/[.,!?:;]/g, '').trim();
  };

  const renderTappableText = (text: string, isCurrentlyPlaying: boolean) => {
    const words = text.split(' ');
    return (
      <View style={styles.textContainer}>
        {words.map((word, index) => {
          const cleanedWord = cleanWord(word);
          if (!cleanedWord) return null;
          
          return (
            <TouchableOpacity
              key={index}
              onPress={() => {
                if (isCurrentlyPlaying) {
                  handleWordPress(cleanedWord);
                } else {
                  Alert.alert('注意', '単語は現在再生中の字幕からのみ選択できます');
                }
              }}
            >
              <Text style={[
                styles.tappableWord,
                !isCurrentlyPlaying && styles.disabledWord
              ]}>
                {word}{' '}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>
    );
  };

  return (
    <View style={styles.container}>
      <ScrollView 
        ref={scrollViewRef}
        style={styles.scrollContainer}
        contentContainerStyle={styles.contentContainer}
        showsVerticalScrollIndicator={true}
        scrollEventThrottle={16}
      >
        {subtitles.map((subtitle) => {
          const isCurrentlyPlaying = 
            currentTime >= subtitle.startTime && 
            currentTime < subtitle.endTime;

          const decodedText = decodeHtmlEntities(subtitle.text);
          const translationText = subtitle.translation || translations[subtitle.id];
          const isLoading = loadingTranslations[subtitle.id];

          return (
            <TouchableOpacity
              key={subtitle.id}
              onPress={() => handleSubtitlePress(subtitle.startTime)}
              style={getSubtitleItemStyle(subtitle, isCurrentlyPlaying)}
            >
              {renderTappableText(decodedText, isCurrentlyPlaying)}
              {settings.showJapaneseTranslation && (
                isLoading ? (
                  <ActivityIndicator size="small" color="#666666" />
                ) : (
                  translationText && (
                    <Text style={styles.translationText}>{translationText}</Text>
                  )
                )
              )}
            </TouchableOpacity>
          );
        })}

        <Modal
          visible={showWordModal}
          transparent
          animationType="fade"
          onRequestClose={handleModalClose}
        >
          <View style={styles.meaningModal}>
            <View style={styles.meaningContent}>
              <Text style={styles.selectedWord}>{selectedWord}</Text>
              
              {isLoading ? (
                <ActivityIndicator size="small" color="#4A90E2" />
              ) : wordMeaning ? (
                <View style={styles.meaningContainer}>
                  <Text style={styles.japaneseTranslation}>
                    {wordMeaning.japaneseTranslation}
                  </Text>
                </View>
              ) : (
                <Text style={styles.noMeaning}>意味が見つかりませんでした</Text>
              )}
              
              <View style={styles.buttonContainer}>
                <TouchableOpacity
                  style={[styles.modalButton, styles.saveButton]}
                  onPress={handleSaveWord}
                >
                  <Text style={styles.saveButtonText}>保存</Text>
                </TouchableOpacity>
                
                <TouchableOpacity
                  style={[styles.modalButton, styles.closeButton]}
                  onPress={handleModalClose}
                >
                  <Text style={styles.closeButtonText}>閉じる</Text>
                </TouchableOpacity>
              </View>
            </View>
          </View>
        </Modal>
      </ScrollView>
    </View>
  );
};

const formatTime = (seconds: number): string => {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollContainer: {
    flex: 1,
  },
  contentContainer: {
    paddingHorizontal: 16,
    paddingBottom: 16,
  },
  subtitleItem: {
    padding: 12,
    marginTop: 8,
    marginBottom: 0,
    borderRadius: 8,
    backgroundColor: '#f5f5f5',
    borderLeftWidth: 4,
    borderLeftColor: 'transparent',
    minHeight: 80,
    justifyContent: 'flex-start',
  },
  currentSubtitle: {
    backgroundColor: '#e3f2fd',
    borderLeftColor: '#1976d2',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  textContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 8,
  },
  tappableWord: {
    fontSize: 15,
    color: '#2196F3',
    textDecorationLine: 'underline',
    lineHeight: 22,
  },
  translationText: {
    fontSize: 14,
    color: '#666666',
    marginTop: 6,
    lineHeight: 20,
  },
  meaningModal: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  meaningContent: {
    backgroundColor: 'white',
    padding: 20,
    borderRadius: 10,
    width: '80%',
    alignItems: 'center',
  },
  selectedWord: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  meaning: {
    fontSize: 20,
    textAlign: 'center',
    marginBottom: 20,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
  },
  meaningContainer: {
    width: '100%',
    marginVertical: 15,
  },
  partOfSpeech: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
    marginBottom: 5,
  },
  definition: {
    fontSize: 16,
    lineHeight: 24,
    marginBottom: 10,
  },
  example: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
    marginTop: 5,
  },
  noMeaning: {
    fontSize: 16,
    color: '#666',
    marginVertical: 15,
  },
  saveButton: {
    backgroundColor: '#4CAF50',
  },
  saveButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  closeButton: {
    backgroundColor: '#f5f5f5',
  },
  closeButtonText: {
    color: '#666',
    fontSize: 16,
  },
  japaneseTranslation: {
    fontSize: 20,
    color: '#4CAF50',
    marginBottom: 20,
    textAlign: 'center',
    fontWeight: 'bold',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginTop: 10,
    fontStyle: 'italic',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
    marginTop: 10,
  },
  modalButton: {
    flex: 1,
    padding: 12,
    borderRadius: 5,
    marginHorizontal: 5,
    alignItems: 'center',
  },
  disabledWord: {
    color: '#999',
    textDecorationLine: 'none',
  },
  autoGeneratedSubtitle: {
    paddingVertical: 6,
    paddingHorizontal: 12,
    minHeight: 70,
  },
});

export default SubtitleDisplay;